{-# OPTIONS --cubical #-}module Syntax0 whereopen import Data.Nat hiding (_^_)open import Data.Bool hiding  (_∨_ ; _∧_)open import Cubical.Core.Everythingopen import Cubical.Foundations.Preludeopen import Cubical.Foundations.Isomorphism renaming (Iso to _≅_)open import SqrtPathinfix  19 _⇔_infix  18 _↔_infixr 25 _⊙_infixr 27 _^_infixr 21 _▣_data Π₂ : Type where  𝔹 : Π₂data _↔_ : (A B : Π₂) → Type where  id₁   : {A : Π₂} → (A ↔ A)  not₁  : 𝔹 ↔ 𝔹  !₁_   : {A B : Π₂} → (A ↔ B) → (B ↔ A)  _⊙_   : {A B C : Π₂} → (A ↔ B) → (B ↔ C) → (A ↔ C)  _^_   : {A : Π₂} → (c : A ↔ A) → (n : ℕ) → (A ↔ A)  sqrt  : {A : Π₂} → (c : A ↔ A) → (A ↔ A)data _⇔_ : {A B : Π₂} (p q : A ↔ B) → Type where  -- some names are bad  id₂   : {A B : Π₂} {c : A ↔ B} → c ⇔ c  !₂_   : {A B : Π₂} {p q : A ↔ B} → (p ⇔ q) → (q ⇔ p)  _⊙₂_  : {A B : Π₂} {p q r : A ↔ B} → (p ⇔ q) → (q ⇔ r) → (p ⇔ r)    sq⊙sq : {A : Π₂} (c : A ↔ A) → sqrt c ⊙ sqrt c ⇔ c  -- sqf   : {A : Π₂} {c : A ↔ A} → sqrt (c ⊙ c) ⇔ sqrt c ⊙ sqrt c  sqf   : {A : Π₂} {p q : A ↔ A} → sqrt (p ⊙ q) ⇔ sqrt p ⊙ sqrt q  sqi   : {A : Π₂} {p q : A ↔ A} → (p ⇔ q) → sqrt p ⇔ sqrt q  sqc   : {A : Π₂} {c : A ↔ A} → sqrt c ⊙ c ⇔ c ⊙ sqrt c -- derivable from assoc and sq⊙sq    c^0   : {A : Π₂} {c : A ↔ A} → c ^ 0 ⇔ id₁  factl : {A : Π₂} {c : A ↔ A} {n : ℕ} → c ^ suc n ⇔ c ⊙ c ^ n  factr : {A : Π₂} {c : A ↔ A} {n : ℕ} → c ^ suc n ⇔ c ^ n ⊙ c  idl⊙l : {A B : Π₂} {c : A ↔ B} → (id₁ ⊙ c) ⇔ c  idr⊙l : {A B : Π₂} {c : A ↔ B} → (c ⊙ id₁) ⇔ c  assoc⊙l : {A B C D : Π₂} {p : A ↔ B} {q : B ↔ C} {r : C ↔ D}          → (p ⊙ q) ⊙ r ⇔ p ⊙ (q ⊙ r)  _▣_   : {A B C : Π₂} {c₁ c₃ : A ↔ B} {c₂ c₄ : B ↔ C}        → (c₁ ⇔ c₃) → (c₂ ⇔ c₄)        -----------------------        → (c₁ ⊙ c₂) ⇔ (c₃ ⊙ c₄)-- equational reasoning of ⇔begin₂_ : {A B : Π₂} → {c₁ c₂ : A ↔ B} → (c₁ ⇔ c₂) → (c₁ ⇔ c₂)begin₂ p = p_end₂ : {A B : Π₂} → (c : A ↔ B) → c ⇔ cc end₂ = id₂_⇔⟨_⟩_ : {A B : Π₂} → (c₁ : A ↔ B) → {c₂ c₃ : A ↔ B}       → (c₁ ⇔ c₂) → (c₂ ⇔ c₃) → (c₁ ⇔ c₃)c₁ ⇔⟨ p ⟩ q = p ⊙₂ q_⇔⟨⟩_ : {A B : Π₂} → (c₁ : A ↔ B) → {c₂ : A ↔ B}      → (c₁ ⇔ c₂) → (c₁ ⇔ c₂)c₁ ⇔⟨⟩ q = c₁ ⇔⟨ id₂ ⟩ qinfix 1 begin₂_infix 3 _end₂infixr 2 _⇔⟨_⟩_infixr 2 _⇔⟨⟩_-- examples-- should it hold natually?sqrt-c⊙c : {A : Π₂} {c : A ↔ A} → sqrt (c ⊙ c) ⇔ csqrt-c⊙c {A} {c} =  begin₂    sqrt (c ⊙ c)  ⇔⟨ sqf ⟩    sqrt c ⊙ sqrt c  ⇔⟨ sq⊙sq c ⟩    c  end₂-- sqrt (c ^ 3) ⇔ sqrt c ⊙ c-- sqrt (c ^ 3) ⇔ c ⊙ sqrt csqrt-c^3-l : {A : Π₂} {c : A ↔ A} → sqrt (c ^ 3) ⇔ sqrt c ⊙ csqrt-c^3-l {A} {c} =  begin₂    sqrt (c ^ 3)  ⇔⟨ sqi factl ⟩    sqrt (c ⊙ c ^ 2)  ⇔⟨ sqf ⟩    sqrt c ⊙ sqrt (c ^ 2)  ⇔⟨ id₂ ▣ sqi factl ⟩    sqrt c ⊙ sqrt (c ⊙ c ^ 1)  ⇔⟨ id₂ ▣ sqf ⟩    sqrt c ⊙ (sqrt c ⊙ sqrt (c ^ 1))  ⇔⟨ id₂ ▣ id₂ ▣ sqi factl  ⟩    sqrt c ⊙ (sqrt c ⊙ sqrt (c ⊙ c ^ 0))  ⇔⟨ id₂ ▣ id₂ ▣ sqi (id₂ ▣ c^0) ⟩  -- ʻid₂ ▣ ʻid₂ ▣ ʻsqf ???    sqrt c ⊙ (sqrt c ⊙ sqrt (c ⊙ id₁))  ⇔⟨ id₂ ▣ id₂ ▣ sqi idr⊙l ⟩    sqrt c ⊙ (sqrt c ⊙ sqrt c)  ⇔⟨ id₂ ▣ sq⊙sq c ⟩    sqrt c ⊙ c  end₂  sqrt-c^3-r : {A : Π₂} {c : A ↔ A} → sqrt (c ^ 3) ⇔ c ⊙ sqrt csqrt-c^3-r {A} {c} =  begin₂    sqrt (c ^ 3)  ⇔⟨ sqrt-c^3-l ⟩    sqrt c ⊙ c  ⇔⟨ sqc ⟩    c ⊙ sqrt c  end₂{--explore the behavior of (sqrt id) and (sqrt not) :(sqrt id)  : can be id SUPEROR not(sqrt not) : ...--}⟦_⟧ : Π₂ → Type⟦ 𝔹 ⟧ = Boolnot-path : Bool ≡ Boolnot-path = isoToPath (iso not not rem rem)  where    rem : (b : Bool) → not (not b) ≡ b    rem false = refl    rem true  = refl{-# TERMINATING #-}eval↔to≡ : {A B : Π₂} (i : I) (c : A ↔ B) → ⟦ A ⟧ ≡ ⟦ B ⟧eval↔to≡ i id₁         = refleval↔to≡ i not₁        = not-patheval↔to≡ i (!₁ c)      = sym (eval↔to≡ i c)eval↔to≡ i (p ⊙ q)     = eval↔to≡ i p ∙ eval↔to≡ i qeval↔to≡ i (c ^ 0)     = refleval↔to≡ i (c ^ suc n) = eval↔to≡ i c ∙ eval↔to≡ i (c ^ n)eval↔to≡ i (sqrt c)    = {!!}-- fst (sqrt≡ (eval↔to≡ i {!!}) i)eval0 : Bool ≡ Bool → (i : I) → Partial (~ i ∨ i) Booleval0 p i (i = i0) = trueeval0 p i (i = i1) = transport p true